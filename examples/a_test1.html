<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - mirror</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>

		
		<link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
		<script src="https://code.jquery.com/jquery-3.6.0.js"></script>
		<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
	</head>
	<body>

		<div id="container"></div>
	 

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			let uiHTML = `
				<div class="" style="position: fixed;
					left: 10%;
					top:60%;
					width: 80%;
					box-sizing: border-box;
					z-index:2 !important;; /* TODO Solve this in HTML */
					background:#fff">
						<span id="xyzInfo" style="margin-left:100px; width:500px;"></span>
						<div id="timeStepSlider"></div>
						<button id="junkButton">junk</button>
						<span id="junkResult"></span>
						<button id="outputCsvButton">outputCSV</button>
						<div id="myChart">
						</div>
				</div>
			`;

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Reflector } from 'three/addons/objects/Reflector.js';
            import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
			import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
			import { TransformControls } from 'three/addons/controls/TransformControls.js';

			import {default as CSG} from 'three/addons/a_test/three-csg.js';

			console.log(CSG);
			let camera, scene, renderer;
			let stats;
			let cameraControls, transformControls;

			let sphereGroup, smallSphere;

			let selectMesh;
			let groupMesh
			let maxHeight = 0;
			let splitCnt = 4;
			let sensorXList;
			let sensorYList;
			let sensorZList;
			let animCount = 0;
			let isSliding = false;
			let startMinDateGlobal = 0;
			let hz = 100.0; //20hz
			const clock = new THREE.Clock();

			let infoView = undefined;
			let timeStepSlider = undefined;

			let framecnt = 0;
			let sumFrame = 0;
			let t_privouseTime = 0;
			let t_currentTime = Number.POSITIVE_INFINITY;
			let t_diffTime = 0;
			let speedAnim = 20;
			let isOriginSpeed = true;

			const windowsChrome = isChromiumBased() && isWindows();

			init();
			animate();

			function init() {

				const container = document.getElementById( 'container' );

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				document.body.appendChild( stats.dom );

				// scene
				scene = new THREE.Scene();

				// world
				scene = new THREE.Scene();
				// lights 
				let light1 = new THREE.DirectionalLight(0xffffff, 1);
                light1.position.set(-100, 0, 100);
                let light2 = new THREE.DirectionalLight(0xffffff, 1);
                light2.position.set(100, 0, 100);
                let light3 = new THREE.DirectionalLight(0xffffff, 1);
                light3.position.set(100, 0, -100);
                scene.add(light1);
                scene.add(light2);
                scene.add(light3);

				// camera
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( 0, -200, 15 );

				
				cameraControls = new OrbitControls( camera, renderer.domElement );
				cameraControls.rotateSpeed = 1.0;
                cameraControls.zoomSpeed = 1.2;
                cameraControls.panSpeed = 0.8;
                cameraControls.minDistance = 3;
                cameraControls.maxDistance = 1000; 
					

				const axesHelper = new THREE.AxesHelper( 1000 );
				scene.add( axesHelper );

				// transform gizmo
				transformControls = new TransformControls( camera, renderer.domElement );
				transformControls.addEventListener( 'dragging-changed', ( event ) => { 
					console.log(event);
				} );

				scene.add( transformControls );

				window.addEventListener( 'resize', onWindowResize );

                const objLoader = new OBJLoader();
				const mtlLoader = new MTLLoader();
				mtlLoader.setMaterialOptions({side: THREE.BackSide})
                // load a resource
                mtlLoader.load(
                    // resource URL
                    'a_test/final_object file279788_115006.mtl',
                    // called when resource is loaded
                    function ( MaterialCreator ) {
						MaterialCreator.preload();
						objLoader.setMaterials(MaterialCreator);
						objLoader.load('a_test/final_object file279788_115006.obj', function(object){
							scene.add( object );
							//cameraControls.target = new THREE.Vector3(-3118975.5, 4081848, 3780465.25);
							camera.lookAt(object.position);
							groupMesh = object;
							let pos;
							let m1Pos;
							let maxHeightIndex = 0;
							for(let i=0; i<object.children.length; ++i){
								if(i>0)continue;
								let child = object.children[i];
								child.material = buildTwistMaterial(child.material, 2.0 );

								let index = 0; 
								let minX = Number.POSITIVE_INFINITY;
								let minY = Number.POSITIVE_INFINITY;
								let minZ = Number.POSITIVE_INFINITY;
								let maxX = Number.NEGATIVE_INFINITY;
								let maxY = Number.NEGATIVE_INFINITY;
								let maxZ = Number.NEGATIVE_INFINITY;
								for(let j=0; j<child.geometry.attributes.position.count; ++j){ 
									let _x = child.geometry.attributes.position.array[index];
									index++;
									let _y = child.geometry.attributes.position.array[index];
									index++;
									let _z = child.geometry.attributes.position.array[index];
									index++;

									minX = Math.min(minX, _x);
									minY = Math.min(minY, _y);
									minZ = Math.min(minZ, _z);
									maxX = Math.max(maxX, _x);
									maxY = Math.max(maxY, _y);
									maxZ = Math.max(maxZ, _z); 
								}
					 
								let width = maxX - minX;
								let height = maxY - minY;
								let depth = maxZ - minZ;

								index = 0;
								
								for(let j=0; j<child.geometry.attributes.position.count; ++j){
									let transX = child.geometry.attributes.position.array[index] - maxX + (width/2);
									child.geometry.attributes.position.array[index] = transX;
									index++;
									let transY = child.geometry.attributes.position.array[index] - maxY + (height/2);
									child.geometry.attributes.position.array[index] = transY;
									index++;
									let transZ = child.geometry.attributes.position.array[index] - maxZ + (depth/2);
									child.geometry.attributes.position.array[index] = transZ;
									index++;
								}
								
								child.geometry.attributes.position.needsUpdate = true;
								pos = getCenterPoint(child);

								for(let i=0; i<object.children.length; ++i){
									let child = object.children[i];
									let height = getHeight(child);
									if(height > maxHeight){
										maxHeight = height;
										maxHeightIndex = i;
									}
								}
								
								if(i == 0)m1Pos = pos.clone();
								if(i > 0)child.position.x = m1Pos.x - pos.x;
								else child.position.x = -pos.x;
							}

							selectMesh = object.children[maxHeightIndex];

							selectMesh.geometry.computeBoundingBox();
							for(let i=0; i<object.children.length; ++i){
								let child = object.children[i];
								child.position.z -= selectMesh.geometry.boundingBox.min.z;  
							}

							console.log(selectMesh);

							transformControls.attach( object );
								
							preProcess();
						}, function (xhr) {
							console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
						}, function (error) {
							console.log( 'An error happened', error);
						});
                    },
                    // called when loading is in progresses
                    function ( xhr ) {
						// 로드되는 동안 호출되는 함수
						console.log('MTLLoader: ', xhr.loaded / xhr.total * 100, '% loaded');
                    },
                    // called when loading has errors
                    function ( error ) {
						// 로드가 실패했을때 호출하는 함수
						console.error('MTLLoader 로드 중 오류가 발생하였습니다.', error);
						alert('MTLLoader 로드 중 오류가 발생하였습니다.');
                    }
                );

			}

			async function preProcess(){
				const effectController = {
					k_v2: 0.5,
				};

				const matChanger = function ( ) {
					if(selectMesh){
						const shader = selectMesh.material.userData.shader;
						if(shader){
							shader.uniforms.k_v2.value = effectController.k_v2;
						}
					}
				};
				
				const gui = new GUI();
				gui.add( effectController, 'k_v2', 0.1, 50.0, 0.1 ).onChange( matChanger );
				matChanger();

				let geometry = selectMesh.geometry;
				 

				/*데이터 입력*/
				sensorXList = await getMseedData('a_test/output_CP_BEB_HCX_20221029082749.mseed');
				sensorYList = await getMseedData('a_test/output_CP_BEB_HCY_20221029082749.mseed');
				sensorZList = await getMseedData('a_test/output_CP_BEB_HCZ_20221029082749.mseed');
				
				/*앞뒤로 누락된 데이터를 0으로 채워준다 start*/
				
				//UTC(universal time coordinated)->KST(korea standard time)
				/* 20 hz
				let startDateX = 1666967236200 + 9 * 60 * 60 * 1000;
				let startDateY = 1666967236800 + 9 * 60 * 60 * 1000;
				let startDateZ = 1666967235400 + 9 * 60 * 60 * 1000;
				*/
				//100 hz
				let startDateX = 1666967237680 + 9 * 60 * 60 * 1000 *2; //toISOString()스트링으로 출력하면 utc로 출력되므로 9*2시간을 더해주었다.
				let startDateY = 1666967237440 + 9 * 60 * 60 * 1000 *2;
				let startDateZ = 1666967238060 + 9 * 60 * 60 * 1000 *2;
				
				let sec1 = sensorXList.length / hz;
				let sec2 = sensorYList.length / hz;
				let sec3 = sensorZList.length / hz;

				let endDateX = startDateX + sec1 * 1000;
				let endDateY = startDateY + sec2 * 1000;
				let endDateZ = startDateZ + sec3 * 1000;

				let startMinDate = Math.min(startDateX, startDateY, startDateZ);
				startMinDateGlobal = startMinDate;
				let endMaxDate = Math.max(endDateX, endDateY, endDateZ);
 
				let startOffsetX = startMinDate - startDateX; 
				let endOffsetX = endMaxDate - endDateX;
				let startOffsetY = startMinDate - startDateY;
				let endOffsetY = endMaxDate - endDateY;
				let startOffsetZ = startMinDate - startDateZ;
				let endOffsetZ = endMaxDate - endDateZ;

				let addedStartXDate = startDateX + startOffsetX;
				let addedStartYDate = startDateY + startOffsetY;
				let addedStartZDate = startDateZ + startOffsetZ;

				let addedEndXDate = endDateX + endOffsetX;
				let addedEndYDate = endDateY + endOffsetY;
				let addedEndZDate = endDateZ + endOffsetZ;

				let addedStartXCnt = Math.abs(startOffsetX / 1000 * hz);
				let addedStartYCnt = Math.abs(startOffsetY / 1000 * hz);
				let addedStartZCnt = Math.abs(startOffsetZ / 1000 * hz);
				let addedEndXCnt = Math.abs(endOffsetX / 1000 * hz);
				let addedEndYCnt = Math.abs(endOffsetY / 1000 * hz);
				let addedEndZCnt = Math.abs(endOffsetZ / 1000 * hz);

				function addStartPos(cnt, list){
					for(let i=0; i<cnt; ++i){
						list.unshift(0);
					}
				}
				function addEndPos(cnt, list){
					for(let i=0; i<cnt; ++i){
						list.push(0);
					}
				}
				
				addStartPos(addedStartXCnt, sensorXList);
				addStartPos(addedStartYCnt, sensorYList);
				addStartPos(addedStartZCnt, sensorZList);
				addEndPos(addedEndXCnt, sensorXList);
				addEndPos(addedEndYCnt, sensorYList);
				addEndPos(addedEndZCnt, sensorZList);
 				/*앞뒤로 누락된 데이터를 0으로 채워준다 end*/

				/*playbar 생성*/
				$('body').append(uiHTML);
				infoView = $('#xyzInfo');
				$("#timeStepSlider").slider({
					range: "min",
					step: 10,
					value: startMinDate,
					min: startMinDate,
					max: endMaxDate - 100,
					slide: function (event, ui) {
						//$('#timeStepValue').text(new Date(ui.value));
						let diffTime = ui.value - startMinDate;
						animCount = Math.floor(diffTime/1000*hz);
						//$('#timeXYZ').text('x:'+sensorXList[animCount]+' y:'+sensorYList[animCount]+' z:'+sensorZList[animCount]);
					},
					start: function(event, ui){
						isSliding = true;
					},
					stop: function(event, ui){
						isSliding = false;
					},
				});
				timeStepSlider = $("#timeStepSlider");
				/*playbar 생성 끝/

				/*데이터 입력 끝*/ 

				postProcess();
			}
			
			

			function postProcess(){
				
				initJank();
				initOutputCsv();
				initChartUI(sensorXList); 
			}
			
			/*chart 글로벌 변수 지정*/
			let debug_level = 0;
			let debugList = [[], [0, 10000, 0]];
			for(let i=0; i<100; ++i){
				let max = 10000;
				let min = -10000;
				debugList[0].push(Math.random() * (max - min) + min);
			}
			let originListLength = 0;
			let originList = [];
			let sensorList = [];
			let backCanvas;
			let backCanvasContext;
			
			let settingCanvas;
			let settingCanvasContext;

			let dataCanvas;
			let dataCanvasContext;

			let animLineCanvas;
			let animLineCanvasContext;

			let crossHairCanvas;
			let crossHairCanvasContext;

			let width;
			let height;

			let chart_offset_top;
			let chart_offset_bottom;
			let chart_offset_left;
			let chart_offset_right;
			
			let chart_10000_offset;

			let added_left_offset;
			let start_x_offset;
			let font_height;

			let chartWidth;
			let chartHeight;

			let zero_pos_x;
			let zero_pos_y;

			let originLeftOffset = 0;
			let currentListLen = 0;
			let globalZoomStartIdx = 0;
			let globalZoomEndIdx = 0;

			/*드래그 이벤트*/
			let Left = 0;
			let Middle = 1;
			let Right = 2;
			let Fourth = 3;
			let Fifth = 4;
			let _mouseMoveStartPositionX = 0;
			let _mousePressed = false;

			let preMovePosX = 0;
			let dragDirection = Left;
			
			function initChartUI(sensorListParam){
				if(debug_level == 0){
					sensorList = sensorListParam.slice();
				}else if(debug_level == 1){
					sensorList = debugList[0].slice();
				}else if(debug_level == 2){
					sensorList = debugList[1].slice();
				}
				originListLength = sensorList.length;
				originList = sensorList.slice();

				width = $('#timeStepSlider').width();
				height = 300;

				chart_offset_top = 20;
				chart_offset_bottom = 20;
				chart_offset_left = 20;
				chart_offset_right = 20;
				
				chart_10000_offset = height / 5;

				added_left_offset = 30;
				start_x_offset = chart_offset_left + added_left_offset;
				font_height = 8;

				chartWidth = width - start_x_offset - chart_offset_right;
				chartHeight = height - chart_offset_top - chart_offset_bottom;

				zero_pos_x = start_x_offset;
				zero_pos_y = height/2;
				
				$('#myChart').append(`
				<canvas id="backCanvas" style="background: cornsilk;position:absolute;" width="${width}" height="${height}"></canvas>
				<canvas id="settingCanvas" style="position:absolute;" width="${width}" height="${height}"></canvas>
				<canvas id="dataCanvas" style="position:absolute;" width="${width}" height="${height}"></canvas>
				<canvas id="animLineCanvas" style="position:absolute;" width="${width}" height="${height}"></canvas>
				<canvas id="crossHairCanvas" style="position:absolute;" width="${width}" height="${height}"></canvas>
				`);
			
				backCanvas = document.getElementById("backCanvas"); //빈 canvas
				backCanvasContext = backCanvas.getContext("2d");
				
				settingCanvas = document.getElementById("settingCanvas"); //차트 style setting
				settingCanvasContext = settingCanvas.getContext("2d");

				dataCanvas = document.getElementById("dataCanvas"); //데이터뷰, 이벤트처리
				dataCanvasContext = dataCanvas.getContext("2d");

				animLineCanvas = document.getElementById("animLineCanvas"); //애니메이션 라인
				animLineCanvasContext = animLineCanvas.getContext("2d");

				crossHairCanvas = document.getElementById("crossHairCanvas"); //crosshair
				crossHairCanvasContext = crossHairCanvas.getContext("2d");
				
				drawChartSetting(settingCanvasContext);
				drawChartData(dataCanvasContext, sensorList);
				

				crossHairCanvas.addEventListener('wheel', (event=>{  
					wheelEvent(dataCanvasContext, event);
				}));
			 
				crossHairCanvas.addEventListener('mousedown', (e=>{
					if (e.button !== Left) {
						return;
					}
					_mouseMoveStartPositionX = e.offsetX;
					if(_mouseMoveStartPositionX < zero_pos_x || zero_pos_x + chartWidth < _mouseMoveStartPositionX){
						return;
					}
					_mousePressed = true; 
				}));
				
				crossHairCanvas.addEventListener('mousemove', (e=>{ 
					crosshair(crossHairCanvasContext, event.offsetX, event.offsetY);

					if (e.button !== Left) {
						return;
					}
					let mousemovePosX = e.offsetX;
					if(mousemovePosX < zero_pos_x || zero_pos_x + chartWidth < mousemovePosX){
						_mousePressed = false;
						return;
					}
					let dragDistance = _mouseMoveStartPositionX - mousemovePosX; 
					if(_mousePressed && Math.abs(dragDistance) > 5){
						drag(e, dragDistance);
					}
				}));
				crossHairCanvas.addEventListener('mouseup', (e=>{ 
					if (e.button !== Left) {
						return;
					}
					let mousemovePosX = e.offsetX;
					if(mousemovePosX < zero_pos_x || zero_pos_x + chartWidth < mousemovePosX){
						return;
					}
					if(_mousePressed){
						_mousePressed = false;
					}
				}));
				crossHairCanvas.addEventListener('click', (e=>{ 
					if (e.button !== Left) {
						return;
					}
					chartClick(e, animLineCanvasContext);
				}));
			}

			function drawChartSetting(context){
				context.clearRect(0, 0, width, height);
				context.beginPath();

				context.moveTo(width - chart_offset_right, chart_offset_top);
				context.lineTo(width - chart_offset_right, height - chart_offset_bottom);

				context.moveTo(start_x_offset, height - chart_offset_bottom);
				context.lineTo(start_x_offset, chart_offset_top);

				context.moveTo(start_x_offset, height/2);
				context.lineTo(width - chart_offset_right, height/2);
				
				context.font = "12px serif";
				context.fillText("10000", chart_offset_left - 2, zero_pos_y - chart_10000_offset + font_height/2);
				context.fillText("0", start_x_offset - 10, height/2 + font_height/2);
				context.fillText("-10000", chart_offset_left - 10, zero_pos_y + chart_10000_offset + font_height/2);
				
				context.stroke();
			}

			function drawChartData(context, dataList){
				sensorList = dataList;
				context.clearRect(0, 0, width, height);
				context.beginPath();
				for(let i=0; i<dataList.length-1; ++i){
					let xPos = zero_pos_x + chartWidth * (i / (dataList.length - 1));
					let yPos = zero_pos_y - ((chart_10000_offset*dataList[i]) / 10000.0);

					let next_xPos = zero_pos_x + chartWidth * ((i+1) / (dataList.length - 1));
					let next_yPos = zero_pos_y - ((chart_10000_offset*dataList[i+1]) / 10000.0);
					context.moveTo(xPos, yPos);
					context.lineTo(next_xPos, next_yPos);
				}
				
				context.stroke();
			}
			
			function animLine(context, currentTime, animCount){
				context.clearRect(0, 0, width, height);
				context.beginPath();
		 
				let pixcelPerIdx = originList.length / chartWidth;
				let be = animCount / originList.length; 
				let idxPerPixcelLen = be*chartWidth;

				let offsetLeft = idxPerPixcelLen * pixcelPerIdx - originLeftOffset;
				if(offsetLeft < 0){
					return;
				}

				let xPos = zero_pos_x + idxPerPixcelLen;
				let yPos = 20;
				/*y축 그리기*/
				context.setLineDash([5, 10]);
				context.moveTo(xPos, 0);
				context.lineTo(xPos, height);
				context.strokeStyle = '#0000ff';

				 
				let sensorDataIdx = (idxPerPixcelLen*(originList.length - 1)) / chartWidth;
				let f_sensorIdx = Math.round(sensorDataIdx);
				//let sensorData = originList[f_sensorIdx];
				let sensorData = originList[animCount];
				let y = zero_pos_y - ((chart_10000_offset*sensorData) / 10000.0);

				let interpolation = false;
				if(interpolation){
					let isLastData = f_sensorIdx+1 == originList.length;
					let sensorData2 = 0;
					let y2 = 0;
					let decimalPointBelow = 0;
					let dy = 0;
					let sensorData_delta = 0;
					if(isLastData){
						sensorData2 = originList[f_sensorIdx];
						dy = zero_pos_y - ((chart_10000_offset*sensorData2) / 10000.0);
						sensorData_delta = sensorData2;
					}else{
						sensorData2 = originList[f_sensorIdx+1];
						y2 = zero_pos_y - ((chart_10000_offset*sensorData2) / 10000.0);
						decimalPointBelow = sensorDataIdx - f_sensorIdx;
						dy = THREE.MathUtils.lerp(y, y2, decimalPointBelow);
						sensorData_delta = THREE.MathUtils.lerp(sensorData, sensorData2, decimalPointBelow);
					}
					context.moveTo(zero_pos_x, dy);
					context.lineTo(zero_pos_x + chartWidth, dy);

					/*dot point 그리기*/
					context.fillStyle = '#0000ff';
					context.arc(xPos, dy, 3, 0, 2 * Math.PI, true);
					context.fill();

					/*label*/
					context.font = "12px serif";
					let s_sensorData = sensorData_delta.toFixed(2);
					let measure = context.measureText(s_sensorData);
					context.fillText(s_sensorData, xPos, yPos);
				}else{
					context.moveTo(zero_pos_x, y);
					context.lineTo(zero_pos_x + chartWidth, y);

					/*dot point 그리기*/
					context.fillStyle = '#0000ff';
					context.arc(xPos, y, 3, 0, 2 * Math.PI, true);
					context.fill();

					/*label*/
					context.font = "12px serif";
					let s_sensorData = sensorData.toFixed(2);
					let measure = context.measureText(s_sensorData);
					context.fillText(s_sensorData, xPos, yPos);
				}
				context.stroke();
			}
			
			function crosshair(context, mouseX, mouseY){
				/*clear context*/
				context.clearRect(0, 0, width, height);
				context.beginPath();
				
				if(mouseX < zero_pos_x || zero_pos_x + chartWidth < mouseX){
					return;
				}

				/*y축 그리기*/
				context.setLineDash([5, 10]);
				context.moveTo(mouseX, 0);
				context.lineTo(mouseX, height);
				context.strokeStyle = '#ff00ff';

				/*x축 그리기*/
				let x = mouseX - zero_pos_x;
				let sensorDataIdx = (x*(sensorList.length - 1)) / chartWidth;
				let f_sensorIdx = Math.floor(sensorDataIdx);
				let sensorData = sensorList[f_sensorIdx];
			
				let y = zero_pos_y - ((chart_10000_offset*sensorData) / 10000.0);

				let interpolation = true;
				if(interpolation){
					let isLastData = f_sensorIdx+1 == sensorList.length;
					let sensorData2 = 0;
					let y2 = 0;
					let decimalPointBelow = 0;
					let dy = 0;
					let sensorData_delta = 0;
					if(isLastData){
						sensorData2 = sensorList[f_sensorIdx];
						dy = zero_pos_y - ((chart_10000_offset*sensorData2) / 10000.0);
						sensorData_delta = sensorData2;
					}else{
						sensorData2 = sensorList[f_sensorIdx+1];
						y2 = zero_pos_y - ((chart_10000_offset*sensorData2) / 10000.0);
						decimalPointBelow = sensorDataIdx - f_sensorIdx;
						dy = THREE.MathUtils.lerp(y, y2, decimalPointBelow);
						sensorData_delta = THREE.MathUtils.lerp(sensorData, sensorData2, decimalPointBelow);
					}
					context.moveTo(zero_pos_x, dy);
					context.lineTo(zero_pos_x + chartWidth, dy);

					/*dot point 그리기*/
					context.fillStyle = '#ff00ff';
					context.arc(mouseX, dy, 3, 0, 2 * Math.PI, true);
					context.fill();

					/*label*/
					context.font = "12px serif";
					let s_sensorData = sensorData_delta.toFixed(2);
					let measure = context.measureText(s_sensorData);
					context.fillText(s_sensorData,mouseX - 20, mouseY);
				}else{
					context.moveTo(zero_pos_x, y);
					context.lineTo(zero_pos_x + chartWidth, y);

					/*dot point 그리기*/
					context.fillStyle = '#ff00ff';
					context.arc(mouseX, y, 3, 0, 2 * Math.PI, true);
					context.fill();

					/*label*/
					context.font = "12px serif";
					let s_sensorData = sensorData.toFixed(2);
					let measure = context.measureText(s_sensorData);
					context.fillText(s_sensorData,mouseX - 20, mouseY);
				}
				
				context.stroke();
			}

			function wheelEvent(context, event){
				if(event.offsetX < zero_pos_x || zero_pos_x + chartWidth < event.offsetX){
					return;
				}

				if (event.deltaX === 0 && event.deltaY === 0) {
					return;
				}
		
				const scrollSpeedAdjustment = _determineWheelSpeedAdjustment(event);
				const deltaY = -(scrollSpeedAdjustment * event.deltaY / 100);
		
				if (event.cancelable) {
					event.preventDefault();
				}
		
				if (deltaY !== 0) {
					if(deltaY > 0){
						zoomIn(0.1, event);
					}else{
						zoomOut(0.1, event);
					}
					
				}
			}

			function zoomIn(zoomScale, event){
				let x = event.offsetX - zero_pos_x;
				let sensorDataIdx = (x*(sensorList.length-1)) / chartWidth;
				
				let displayLen = sensorList.length - (sensorList.length * zoomScale);
				//console.log('zoomIn', sensorList.length, displayLen);
				if(sensorXList.length < displayLen){
					return;
				}
				currentListLen = displayLen;

				let diffLen = sensorList.length - displayLen;
				let leftP = sensorDataIdx/(sensorList.length-1);
				let nextIdx = displayLen * leftP;

				let leftAddedCnt = diffLen * leftP;
				let rightAddedCnt = diffLen * (1 - leftP);
				
				let leftIdx = leftAddedCnt;
				let rightIdx = sensorList.length - rightAddedCnt;

				let currentStartIdx = originLeftOffset;
				let currentEndIdx = sensorList.length + currentStartIdx;

				let currentLen = currentEndIdx - currentStartIdx;

				let nextStartIdx = currentStartIdx + leftAddedCnt;
				let nextEndIdx = currentEndIdx - rightAddedCnt;

			 

				originLeftOffset += leftIdx;

				nextStartIdx = Math.round(nextStartIdx);
				if(nextStartIdx < 0){
					nextStartIdx = 0;
				}

				nextEndIdx = Math.round(nextEndIdx);
				if(nextEndIdx >= originList.length){
					nextEndIdx = originList.length;
				}


				globalZoomStartIdx = nextStartIdx;
				globalZoomEndIdx = nextEndIdx;
				//console.log('sensorDataIdx:'+sensorDataIdx, 'nextIdx'+nextIdx, 'leftAddedCnt:'+leftAddedCnt, 'rightAddedCnt:'+rightAddedCnt, 'leftIdx:'+leftIdx, 'rightIdx:'+rightIdx);

				let zoomDataList = undefined;
				zoomDataList = sensorList.slice(Math.round(leftIdx), Math.round(rightIdx));
				drawChartData(dataCanvasContext, zoomDataList);
				crosshair(crossHairCanvasContext, event.offsetX, event.offsetY);
				
			}

			function zoomOut(zoomScale, event){ 
				let x = event.offsetX - zero_pos_x;
				let sensorDataIdx = (x*(sensorList.length-1)) / chartWidth;
				let originalCurrentIdx = (x*(originList.length-1)) / chartWidth;
				
				let displayLen = sensorList.length + (sensorList.length * zoomScale);
				//console.log('zoomOut', sensorList.length, displayLen);
			 
				if(displayLen < 0){
					return;
				}

				currentListLen = displayLen;

				let diffLen = displayLen - sensorList.length;
				let leftP = sensorDataIdx/(sensorList.length-1);
				let nextIdx = displayLen * leftP;

				let leftStartIdx = displayLen * leftP;
				let rightEndIdx = displayLen * (1 - leftP);

				
				let leftAddedCnt = diffLen * leftP;
				let rightAddedCnt = diffLen * (1 - leftP);

				let currentStartIdx = originLeftOffset;
				let currentEndIdx = sensorList.length + currentStartIdx;

				let currentLen = currentEndIdx - currentStartIdx;

				let nextStartIdx = currentStartIdx - leftAddedCnt;
				let nextEndIdx = currentEndIdx + rightAddedCnt;


				originLeftOffset-=leftAddedCnt;
				if(originLeftOffset < 0){
					originLeftOffset = 0;
				}
				//console.log('originLeftOffset:'+originLeftOffset);
				let leftIdx = nextStartIdx;
				let rightIdx = nextEndIdx;

				leftIdx = Math.round(leftIdx);
				if(leftIdx < 0){
					leftIdx = 0;
				}

				rightIdx = Math.round(rightIdx);
				if(rightIdx >= originList.length){
					rightIdx = originList.length;
				}

				globalZoomStartIdx = leftIdx;
				globalZoomEndIdx = rightIdx;
				
				let zoomDataList = originList.slice(Math.round(leftIdx), Math.round(rightIdx));
				drawChartData(dataCanvasContext, zoomDataList);
				
				crosshair(crossHairCanvasContext, event.offsetX, event.offsetY);
			}

			function drag(event, distance){
				if(currentListLen <= 0){
					return;
				}

				let diff = preMovePosX - event.offsetX;
				preMovePosX = event.offsetX;
				if(Math.abs(diff) > 100){
					return;
				}

				if(diff < 0){
					dragDirection = Left;
				}else{
					dragDirection = Right;
				}
				
				let x = event.offsetX - zero_pos_x;
				let sensorDataIdx = (x*(sensorList.length-1)) / chartWidth;
				let originalCurrentIdx = (x*(originList.length-1)) / chartWidth;
				
				let be = sensorList.length / chartWidth;
				let dragScale = diff * be;
				
				//console.log(diff, be, testScale, sensorDataIdx, originalCurrentIdx);
				
				let splitStartIdx = globalZoomStartIdx + dragScale;
				let splitEndIdx = globalZoomEndIdx + dragScale;
				
				if(splitStartIdx < 0 || splitEndIdx > originList.length){
					return;
				}

				originLeftOffset+=dragScale;

				globalZoomStartIdx = splitStartIdx;
				globalZoomEndIdx = splitEndIdx;
				
				let zoomDataList = originList.slice(Math.round(splitStartIdx), Math.round(splitEndIdx));
				drawChartData(dataCanvasContext, zoomDataList);
				
				crosshair(crossHairCanvasContext, event.offsetX, event.offsetY); 
			}

			function chartClick(event, context){
				
				let be = sensorList.length / chartWidth;

				let x = event.offsetX - zero_pos_x;
				let sensorDataIdx = (x*(sensorList.length-1)) / chartWidth;
				let originalCurrentIdx = (x*(originList.length-1)) / chartWidth;
   
				

				let currentStartIdx = originLeftOffset;
				let currentEndIdx = sensorList.length + currentStartIdx;

				let currentLen = currentEndIdx - currentStartIdx;

				let currentDataIdx = sensorDataIdx + originLeftOffset;

				let be2 = sensorDataIdx / sensorList.length; 
				let idxPerPixcel = be2*chartWidth;

				let xPos = zero_pos_x + idxPerPixcel;
				
				animCount = Math.floor(currentDataIdx);
				
				console.log('currentLen:'+currentLen, 'currentStartIdx:'+currentStartIdx, 'currentEndIdx:'+currentEndIdx);
			  
				
				 
			//	drawChartData(dataCanvasContext, zoomDataList);
				
				//crosshair(crossHairCanvasContext, event.offsetX, event.offsetY); 
			}

			async function getMseedData(url){
				let res = await fetch(url);
				let resTxt = await res.text();
				let resList = resTxt.split(' ');
				for(let i=0; i<resList.length; ++i){
					resList[i] = Number(resList[i]);
				}
				return resList;
			}
 

			function buildTwistMaterial( material, amount ) {
				
				material.onBeforeCompile = function ( shader ) {

					shader.uniforms.time = { value: 0 };
					shader.uniforms.sensor_x = { value: 0 };
					shader.uniforms.sensor_y = { value: 0 };
					shader.uniforms.sensor_z = { value: 0 };
					shader.uniforms.k_v2 = { value: 0.5 };
					/* 
						`float theta = cos( time*5. );`,
						'mat3 m = mat3( 1., 0, 0, 0, 1, 0, 0, 0, 1);',
							
						'	m = mat3( 1., 0, theta/5., 0, 1, 0, 0, 0, 1);',
							
						'vec3 transformed = vec3( position ) * m;'
					*/

					/*
						'float dx = sin(sensor_x / 10000.);',
						'mat3 m = mat3( 1., 0, dx/k_v2, 0, 1., 0, 0, 0, 1.);', 
							
						'vec3 transformed = vec3( position ) * m;'
					*/
					let header = `
						uniform float time;\n
						uniform float sensor_x;\n
						uniform float sensor_y;\n
						uniform float sensor_z;\n
						uniform float k_v2;\n
					`;
					shader.vertexShader = header + shader.vertexShader;
					shader.vertexShader = shader.vertexShader.replace(
						'#include <begin_vertex>',
						[ 
							'float dx = sin(sensor_x / 10000.);',
							'float dy = sin(sensor_y / 10000.);',
							'float dz = sin(sensor_y / 10000.);',
							'mat3 m = mat3( 1., 0., dx/k_v2, 0, 1., dy/k_v2, dz/k_v2, 0, 1.);',
							'vec3 transformed = vec3( position ) * m;'
						].join( '\n' )
					);

					console.log(shader.vertexShader);
					material.userData.shader = shader;

				};

				// Make sure WebGLRenderer doesnt reuse a single program

				material.customProgramCacheKey = function () {

					return amount;

				};

				return material;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}



			function animate() {

				requestAnimationFrame( animate );
				t_privouseTime = t_currentTime;

				let timeDelta = clock.getDelta();
				sumFrame += timeDelta;
				if(sumFrame > 1.0){
					//console.log(framecnt);
					//console.log(sumFrame);
					framecnt = 0;
					sumFrame = 0;
				}
				framecnt++;
			
				
				if(selectMesh){
					const shader = selectMesh.material.userData.shader;

					if ( shader && sensorXList && sensorYList && sensorZList) {
						let currentTime = startMinDateGlobal + (animCount * 1/hz * 1000);
						t_currentTime = currentTime;
						t_diffTime = currentTime - t_privouseTime;
						if(t_diffTime < 1000){
							//console.log(t_diffTime);
						}


						shader.uniforms.time.value = timeDelta;
						let _animCount = Math.floor(animCount);
						let xT = sensorXList[_animCount];
						let yT = sensorYList[_animCount];
						let zT = sensorZList[_animCount];

						shader.uniforms.sensor_x.value = xT;
						shader.uniforms.sensor_y.value = yT;
						shader.uniforms.sensor_z.value = zT;
						
						//console.log('' + animCount + '/' + sensorXList.length, xT, yT, zT);
						

						if(infoView){
						
							timeStepSlider.slider('value',currentTime);
							infoView.text(''+ new Date(currentTime).toISOString() + ' 진행:'+ (_animCount/sensorXList.length*100).toFixed(2) + '% ' + '    ' + _animCount + '/' + sensorXList.length + '     x:'+xT+'     y:'+yT+'     z:'+zT);

							animLine(animLineCanvasContext, currentTime, _animCount);
						}

						

						if(!isSliding){
							//animCount++;
							if(t_diffTime <= hz - 0.05 && t_diffTime > hz + 0.05){
								animCount = animCount + timeDelta * speedAnim;
							}else if(t_diffTime < hz - 0.05){
								speedAnim += 0.01;
								animCount = animCount + timeDelta * speedAnim;
							}else if(t_diffTime >= hz + 0.05){
								speedAnim -= 0.01;
								animCount = animCount + timeDelta * speedAnim;
							}
							
						}

						if(animCount > sensorXList.length-1){
							animCount = 0;
							
						}
						
					}
				}
				
				
				renderer.render( scene, camera );
				cameraControls.update();
				stats.update();
	 


				
			}

			function getHeight(mesh){
				var geometry = mesh.geometry;
				geometry.computeBoundingBox();
				return geometry.boundingBox.max.z - geometry.boundingBox.min.z; //건물은 z가 0부터 시작하므로 z의 max값
			}

			function getCenterPoint(mesh) {
				var middle = new THREE.Vector3();
				var geometry = mesh.geometry;
			
				geometry.computeBoundingBox();
			
				middle.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x) / 2;
				middle.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y) / 2;
				middle.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z) / 2;
				
				mesh.localToWorld( middle );
				return middle;
			}

			let interval = null;
			let result = null;

			function initJank() {

				const button = document.getElementById( 'junkButton' );
				button.addEventListener( 'click', function () {

					if ( interval === null ) {

						interval = setInterval( jank, 1000 / 60 );

						button.textContent = 'STOP JANK';

					} else {

						clearInterval( interval );
						interval = null;

						button.textContent = 'START JANK';
						result.textContent = '';

					}

				} );

				result = document.getElementById( 'junkResult' );

			}

			function jank() {

				let number = 0;

				for ( let i = 0; i < 10000000; i ++ ) {

					number += Math.random();

				}

				result.textContent = number;

			}

			function initOutputCsv(){
				$('#outputCsvButton').click(()=>{
					let rows = [
						["StartTime", "Hz", "SampleRate", "x", "y", "z"],
					];
					rows.push([new Date(startMinDateGlobal).toISOString(), String(hz), String(sensorXList.length), '', '', '']);
					for(let i=0; i<sensorXList.length; ++i){
						rows.push(['', '', '', String(sensorXList[i]), String(sensorYList[i]), String(sensorZList[i])]);
					}

					let csvContent = "data:text/csv;charset=utf-8,";

					rows.forEach(function(rowArray) {
						let row = rowArray.join(",");
						csvContent += row + "\r\n";
					});

					var encodedUri = encodeURI(csvContent);
					window.open(encodedUri);
				});
			}

			function _determineWheelSpeedAdjustment(event) {
				switch (event.deltaMode) {
					case event.DOM_DELTA_PAGE:
						// one screen at time scroll mode
						return 120;
					case event.DOM_DELTA_LINE:
						// one line at time scroll mode
						return 32;
				}
		
				if (!windowsChrome) {
					return 1;
				}
		
				// Chromium on Windows has a bug where the scroll speed isn't correctly
				// adjusted for high density displays. We need to correct for this so that
				// scroll speed is consistent between browsers.
				// https://bugs.chromium.org/p/chromium/issues/detail?id=1001735
				// https://bugs.chromium.org/p/chromium/issues/detail?id=1207308
				return (1 / window.devicePixelRatio);
			}

			function isChromiumBased() {
				if (!navigator.userAgentData) { return false; }
				return navigator.userAgentData.brands.some(
					(brand) => {
						return brand.brand.includes('Chromium');
					}
				);
			}
			
			function isWindows() {
				// more accurate if available
				if (
					navigator?.userAgentData?.platform
				) {
					return navigator.userAgentData.platform === 'Windows';
				}
				return navigator.userAgent.toLowerCase().indexOf('win') >= 0;
			}
		
			
		
		</script>
	</body>
</html>
