<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - mirror</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				color: #444;
			}
			a {
				color: #08f;
			}
		</style>

		
		<link rel="stylesheet" href="//code.jquery.com/ui/1.13.2/themes/base/jquery-ui.css">
		<script src="https://code.jquery.com/jquery-3.6.0.js"></script>
		<script src="https://code.jquery.com/ui/1.13.2/jquery-ui.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
	</head>
	<body>

		<div id="container"></div>
	 

		<!-- Import maps polyfill -->
		<!-- Remove this when import maps will be widely supported -->
		<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

		<script type="importmap">
			{
				"imports": {
					"three": "../build/three.module.js",
					"three/addons/": "./jsm/"
				}
			}
		</script>

		<script type="module">
			let uiHTML = `
				<div class="" style="position: fixed;
					left: 10%;
					top:60%;
					width: 80%;
					box-sizing: border-box;
					z-index:2 !important;; /* TODO Solve this in HTML */
					background:#fff">
						<span id="xyzInfo" style="margin-left:100px; width:500px;"></span>
						<div id="timeStepSlider"></div>
						<button id="junkButton">junk</button>
						<span id="junkResult"></span>
						<button id="outputCsvButton">outputCSV</button>
						<div id="myChart">
						</div>
				</div>
			`;

			import * as THREE from 'three';

			import Stats from 'three/addons/libs/stats.module.js';
			import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

			import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
			import { Reflector } from 'three/addons/objects/Reflector.js';
            import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';
			import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
			import { TransformControls } from 'three/addons/controls/TransformControls.js';

			import {default as CSG} from 'three/addons/a_test/three-csg.js';

			console.log(CSG);
			let camera, scene, renderer;
			let stats;
			let cameraControls, transformControls;

			let sphereGroup, smallSphere;

			let selectMesh;
			let groupMesh
			let maxHeight = 0;
			let splitCnt = 4;
			let sensorXList;
			let sensorYList;
			let sensorZList;
			let animCount = 0;
			let isSliding = false;
			let startMinDateGlobal = 0;
			let hz = 100.0; //20hz
			const clock = new THREE.Clock();

			let infoView = undefined;
			let timeStepSlider = undefined;

			let framecnt = 0;
			let sumFrame = 0;
			let t_privouseTime = 0;
			let t_currentTime = Number.POSITIVE_INFINITY;
			let t_diffTime = 0;
			let speedAnim = 20;
			let isOriginSpeed = true;

			init();
			animate();

			function init() {

				const container = document.getElementById( 'container' );

				// renderer
				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				stats = new Stats();
				document.body.appendChild( stats.dom );

				// scene
				scene = new THREE.Scene();

				// world
				scene = new THREE.Scene();
				// lights 
				let light1 = new THREE.DirectionalLight(0xffffff, 1);
                light1.position.set(-100, 0, 100);
                let light2 = new THREE.DirectionalLight(0xffffff, 1);
                light2.position.set(100, 0, 100);
                let light3 = new THREE.DirectionalLight(0xffffff, 1);
                light3.position.set(100, 0, -100);
                scene.add(light1);
                scene.add(light2);
                scene.add(light3);

				// camera
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
				camera.position.set( 0, -200, 15 );

				
				cameraControls = new OrbitControls( camera, renderer.domElement );
				cameraControls.rotateSpeed = 1.0;
                cameraControls.zoomSpeed = 1.2;
                cameraControls.panSpeed = 0.8;
                cameraControls.minDistance = 3;
                cameraControls.maxDistance = 1000; 
					

				const axesHelper = new THREE.AxesHelper( 1000 );
				scene.add( axesHelper );

				// transform gizmo
				transformControls = new TransformControls( camera, renderer.domElement );
				transformControls.addEventListener( 'dragging-changed', ( event ) => { 
					console.log(event);
				} );

				scene.add( transformControls );

				window.addEventListener( 'resize', onWindowResize );

                const objLoader = new OBJLoader();
				const mtlLoader = new MTLLoader();
				mtlLoader.setMaterialOptions({side: THREE.BackSide})
                // load a resource
                mtlLoader.load(
                    // resource URL
                    'a_test/final_object file279788_115006.mtl',
                    // called when resource is loaded
                    function ( MaterialCreator ) {
						MaterialCreator.preload();
						objLoader.setMaterials(MaterialCreator);
						objLoader.load('a_test/final_object file279788_115006.obj', function(object){
							scene.add( object );
							//cameraControls.target = new THREE.Vector3(-3118975.5, 4081848, 3780465.25);
							camera.lookAt(object.position);
							groupMesh = object;
							let pos;
							let m1Pos;
							let maxHeightIndex = 0;
							for(let i=0; i<object.children.length; ++i){
								if(i>0)continue;
								let child = object.children[i];
								child.material = buildTwistMaterial(child.material, 2.0 );

								let index = 0; 
								let minX = Number.POSITIVE_INFINITY;
								let minY = Number.POSITIVE_INFINITY;
								let minZ = Number.POSITIVE_INFINITY;
								let maxX = Number.NEGATIVE_INFINITY;
								let maxY = Number.NEGATIVE_INFINITY;
								let maxZ = Number.NEGATIVE_INFINITY;
								for(let j=0; j<child.geometry.attributes.position.count; ++j){ 
									let _x = child.geometry.attributes.position.array[index];
									index++;
									let _y = child.geometry.attributes.position.array[index];
									index++;
									let _z = child.geometry.attributes.position.array[index];
									index++;

									minX = Math.min(minX, _x);
									minY = Math.min(minY, _y);
									minZ = Math.min(minZ, _z);
									maxX = Math.max(maxX, _x);
									maxY = Math.max(maxY, _y);
									maxZ = Math.max(maxZ, _z); 
								}
					 
								let width = maxX - minX;
								let height = maxY - minY;
								let depth = maxZ - minZ;

								index = 0;
								
								for(let j=0; j<child.geometry.attributes.position.count; ++j){
									let transX = child.geometry.attributes.position.array[index] - maxX + (width/2);
									child.geometry.attributes.position.array[index] = transX;
									index++;
									let transY = child.geometry.attributes.position.array[index] - maxY + (height/2);
									child.geometry.attributes.position.array[index] = transY;
									index++;
									let transZ = child.geometry.attributes.position.array[index] - maxZ + (depth/2);
									child.geometry.attributes.position.array[index] = transZ;
									index++;
								}
								
								child.geometry.attributes.position.needsUpdate = true;
								pos = getCenterPoint(child);

								for(let i=0; i<object.children.length; ++i){
									let child = object.children[i];
									let height = getHeight(child);
									if(height > maxHeight){
										maxHeight = height;
										maxHeightIndex = i;
									}
								}
								
								if(i == 0)m1Pos = pos.clone();
								if(i > 0)child.position.x = m1Pos.x - pos.x;
								else child.position.x = -pos.x;
							}

							selectMesh = object.children[maxHeightIndex];

							selectMesh.geometry.computeBoundingBox();
							for(let i=0; i<object.children.length; ++i){
								let child = object.children[i];
								child.position.z -= selectMesh.geometry.boundingBox.min.z;  
							}

							console.log(selectMesh);

							transformControls.attach( object );
								
							preProcess();
						}, function (xhr) {
							console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
						}, function (error) {
							console.log( 'An error happened', error);
						});
                    },
                    // called when loading is in progresses
                    function ( xhr ) {
						// 로드되는 동안 호출되는 함수
						console.log('MTLLoader: ', xhr.loaded / xhr.total * 100, '% loaded');
                    },
                    // called when loading has errors
                    function ( error ) {
						// 로드가 실패했을때 호출하는 함수
						console.error('MTLLoader 로드 중 오류가 발생하였습니다.', error);
						alert('MTLLoader 로드 중 오류가 발생하였습니다.');
                    }
                );

			}

			async function preProcess(){
				const effectController = {
					k_v2: 0.5,
				};

				const matChanger = function ( ) {
					if(selectMesh){
						const shader = selectMesh.material.userData.shader;
						if(shader){
							shader.uniforms.k_v2.value = effectController.k_v2;
						}
					}
				};
				
				const gui = new GUI();
				gui.add( effectController, 'k_v2', 0.1, 50.0, 0.1 ).onChange( matChanger );
				matChanger();

				let geometry = selectMesh.geometry;
				 

				/*데이터 입력*/
				sensorXList = await getMseedData('a_test/output_CP_BEB_HCX_20221029082749.mseed');
				sensorYList = await getMseedData('a_test/output_CP_BEB_HCY_20221029082749.mseed');
				sensorZList = await getMseedData('a_test/output_CP_BEB_HCZ_20221029082749.mseed');
				
				/*앞뒤로 누락된 데이터를 0으로 채워준다 start*/
				
				//UTC(universal time coordinated)->KST(korea standard time)
				/* 20 hz
				let startDateX = 1666967236200 + 9 * 60 * 60 * 1000;
				let startDateY = 1666967236800 + 9 * 60 * 60 * 1000;
				let startDateZ = 1666967235400 + 9 * 60 * 60 * 1000;
				*/
				//100 hz
				let startDateX = 1666967237680 + 9 * 60 * 60 * 1000;
				let startDateY = 1666967237440 + 9 * 60 * 60 * 1000;
				let startDateZ = 1666967238060 + 9 * 60 * 60 * 1000;
				
				let sec1 = sensorXList.length / hz;
				let sec2 = sensorYList.length / hz;
				let sec3 = sensorZList.length / hz;

				let endDateX = startDateX + sec1 * 1000;
				let endDateY = startDateY + sec2 * 1000;
				let endDateZ = startDateZ + sec3 * 1000;

				let startMinDate = Math.min(startDateX, startDateY, startDateZ);
				startMinDateGlobal = startMinDate;
				let endMaxDate = Math.max(endDateX, endDateY, endDateZ);
 
				let startOffsetX = startMinDate - startDateX; 
				let endOffsetX = endMaxDate - endDateX;
				let startOffsetY = startMinDate - startDateY;
				let endOffsetY = endMaxDate - endDateY;
				let startOffsetZ = startMinDate - startDateZ;
				let endOffsetZ = endMaxDate - endDateZ;

				let addedStartXDate = startDateX + startOffsetX;
				let addedStartYDate = startDateY + startOffsetY;
				let addedStartZDate = startDateZ + startOffsetZ;

				let addedEndXDate = endDateX + endOffsetX;
				let addedEndYDate = endDateY + endOffsetY;
				let addedEndZDate = endDateZ + endOffsetZ;

				let addedStartXCnt = Math.abs(startOffsetX / 1000 * hz);
				let addedStartYCnt = Math.abs(startOffsetY / 1000 * hz);
				let addedStartZCnt = Math.abs(startOffsetZ / 1000 * hz);
				let addedEndXCnt = Math.abs(endOffsetX / 1000 * hz);
				let addedEndYCnt = Math.abs(endOffsetY / 1000 * hz);
				let addedEndZCnt = Math.abs(endOffsetZ / 1000 * hz);

				function addStartPos(cnt, list){
					for(let i=0; i<cnt; ++i){
						list.unshift(0);
					}
				}
				function addEndPos(cnt, list){
					for(let i=0; i<cnt; ++i){
						list.push(0);
					}
				}
				
				addStartPos(addedStartXCnt, sensorXList);
				addStartPos(addedStartYCnt, sensorYList);
				addStartPos(addedStartZCnt, sensorZList);
				addEndPos(addedEndXCnt, sensorXList);
				addEndPos(addedEndYCnt, sensorYList);
				addEndPos(addedEndZCnt, sensorZList);
 				/*앞뒤로 누락된 데이터를 0으로 채워준다 end*/

				/*playbar 생성*/
				$('body').append(uiHTML);
				infoView = $('#xyzInfo');
				$("#timeStepSlider").slider({
					range: "min",
					step: 10,
					value: startMinDate,
					min: startMinDate,
					max: endMaxDate - 100,
					slide: function (event, ui) {
						//$('#timeStepValue').text(new Date(ui.value));
						let diffTime = ui.value - startMinDate;
						animCount = Math.floor(diffTime/1000*hz);
						//$('#timeXYZ').text('x:'+sensorXList[animCount]+' y:'+sensorYList[animCount]+' z:'+sensorZList[animCount]);
					},
					start: function(event, ui){
						isSliding = true;
					},
					stop: function(event, ui){
						isSliding = false;
					},
				});
				timeStepSlider = $("#timeStepSlider");
				/*playbar 생성 끝/

				/*데이터 입력 끝*/ 

				postProcess();
			}
			
			function postProcess(){
				
				initJank();
				initOutputCsv();
				initChartUI(sensorXList);
			}

			function initChartUI(sensorListParam){
				let sensorList = sensorListParam;
	  
				let width = $('#timeStepSlider').width();
				let height = 300;

				let chart_offset_top = 20;
				let chart_offset_bottom = 20;
				let chart_offset_left = 20;
				let chart_offset_right = 20;
				
				let chart_10000_offset = height / 5;

				let added_left_offset = 30;
				let start_x_offset = chart_offset_left + added_left_offset;
				let font_height = 4;

				let chartWidth = width - start_x_offset - chart_offset_right;
				let chartHeight = height - chart_offset_top - chart_offset_bottom;

				let zero_pos_x = start_x_offset;
				let zero_pos_y = height/2;
				
				let _10000 =

				$('#myChart').append(`
				<canvas id="myChartCanvas1" style="background: cornsilk;position:absolute;" width="${width}" height="${height}"></canvas>
				<canvas id="myChartCanvas2" style="position:absolute;" width="${width}" height="${height}"></canvas>
				<canvas id="myChartCanvas3" style="position:absolute;" width="${width}" height="${height}"></canvas>
				 
				`);
			
				let canvas1 = document.getElementById("myChartCanvas1");
				let ctx1 = canvas1.getContext("2d");
				
				let canvas2 = document.getElementById("myChartCanvas2");
				let ctx2 = canvas2.getContext("2d");

				let canvas3 = document.getElementById("myChartCanvas3");
				let ctx3 = canvas3.getContext("2d");

 

				function drawChartSetting(context){
					context.moveTo(width - chart_offset_right, chart_offset_top);
					context.lineTo(width - chart_offset_right, height - chart_offset_bottom);
	
					context.moveTo(start_x_offset, height - chart_offset_bottom);
					context.lineTo(start_x_offset, chart_offset_top);
	
					context.moveTo(start_x_offset, height/2);
					context.lineTo(width - chart_offset_right, height/2);
					
					context.font = "12px serif";
					context.fillText("10000", chart_offset_left - 2, zero_pos_y - chart_10000_offset + font_height/2);
					context.fillText("0", start_x_offset - 10, height/2 + font_height/2);
					context.fillText("-10000", chart_offset_left - 10, zero_pos_y + chart_10000_offset + font_height/2);
					
				}
				drawChartSetting(ctx2);
				

				let x_axis_start_value = startMinDateGlobal;
				let x_axis_end_value = startMinDateGlobal + ((sensorList.length-1) * 1/hz * 1000);
				

				function drawChartData(context){
					for(let i=0; i<sensorList.length-1; ++i){
						let xPos = zero_pos_x + chartWidth * (i / sensorList.length);
						let yPos = zero_pos_y - ((chart_10000_offset*sensorList[i]) / 10000.0);
	
						let next_xPos = zero_pos_x + chartWidth * ((i+1) / sensorList.length);
						let next_yPos = zero_pos_y - ((chart_10000_offset*sensorList[i+1]) / 10000.0);
						context.moveTo(xPos, yPos);
						context.lineTo(next_xPos, next_yPos);
						
						/*dot*/
						//ctx.beginPath();
						//ctx.arc(xPos, yPos, 1, 0, 2 * Math.PI, true);
						//ctx.fill();
					}
					
				
				}
				drawChartData(ctx2);

				function crosshair(context, mouseX, mouseY, clientX, clientY){
					/*clear context*/
					context.clearRect(0, 0, width, height);
					context.beginPath();
					
					if(mouseX < zero_pos_x || zero_pos_x + chartWidth < mouseX){
						return;
					}

					/*y축 그리기*/
					context.setLineDash([5, 10]);
					context.moveTo(mouseX, 0);
					context.lineTo(mouseX, height);
					context.strokeStyle = '#ff00ff';

					/*x축 그리기*/
					let x = mouseX - zero_pos_x;
					let sensorDataIdx = (x*sensorList.length) / chartWidth;
					let sensorData = sensorList[Math.round(sensorDataIdx)];
					let y = zero_pos_y - ((chart_10000_offset*sensorData) / 10000.0);
					context.moveTo(zero_pos_x, y);
					context.lineTo(zero_pos_x + chartWidth, y);

					/*dot point 그리기*/
					context.fillStyle = '#ff00ff';
					context.arc(mouseX, y, 3, 0, 2 * Math.PI, true);
					context.fill();

					/*label*/
					context.font = "12px serif";
					let s_sensorData = String(sensorData);
					let measure = context.measureText(s_sensorData);
					context.fillText(s_sensorData,mouseX - 20, mouseY);
					
					context.stroke();
					context.globalCompositeOperation = 'source-over';
				}

				$('#myChartCanvas3').mousemove(e=>{
					let offsetX = e.originalEvent.offsetX;
					let offsetY = e.originalEvent.offsetY
					let clientX = e.originalEvent.clientX;
					let clientY = e.originalEvent.clientY;
					crosshair(ctx3, offsetX, offsetY, clientX, clientY);
				});

				ctx2.stroke();

				ctx1.drawImage(canvas2, 0, 0);
				ctx1.drawImage(canvas3, 0, 0);
			}

			 

			async function getMseedData(url){
				let res = await fetch(url);
				let resTxt = await res.text();
				let resList = resTxt.split(' ');
				for(let i=0; i<resList.length; ++i){
					resList[i] = Number(resList[i]);
				}
				return resList;
			}
 

			function buildTwistMaterial( material, amount ) {
				
				material.onBeforeCompile = function ( shader ) {

					shader.uniforms.time = { value: 0 };
					shader.uniforms.sensor_x = { value: 0 };
					shader.uniforms.sensor_y = { value: 0 };
					shader.uniforms.sensor_z = { value: 0 };
					shader.uniforms.k_v2 = { value: 0.5 };
					/* 
						`float theta = cos( time*5. );`,
						'mat3 m = mat3( 1., 0, 0, 0, 1, 0, 0, 0, 1);',
							
						'	m = mat3( 1., 0, theta/5., 0, 1, 0, 0, 0, 1);',
							
						'vec3 transformed = vec3( position ) * m;'
					*/

					/*
						'float dx = sin(sensor_x / 10000.);',
						'mat3 m = mat3( 1., 0, dx/k_v2, 0, 1., 0, 0, 0, 1.);', 
							
						'vec3 transformed = vec3( position ) * m;'
					*/
					let header = `
						uniform float time;\n
						uniform float sensor_x;\n
						uniform float sensor_y;\n
						uniform float sensor_z;\n
						uniform float k_v2;\n
					`;
					shader.vertexShader = header + shader.vertexShader;
					shader.vertexShader = shader.vertexShader.replace(
						'#include <begin_vertex>',
						[ 
							'float dx = sin(sensor_x / 10000.);',
							'float dy = sin(sensor_y / 10000.);',
							'float dz = sin(sensor_y / 10000.);',
							'mat3 m = mat3( 1., 0., dx/k_v2, 0, 1., dy/k_v2, dz/k_v2, 0, 1.);',
							'vec3 transformed = vec3( position ) * m;'
						].join( '\n' )
					);

					console.log(shader.vertexShader);
					material.userData.shader = shader;

				};

				// Make sure WebGLRenderer doesnt reuse a single program

				material.customProgramCacheKey = function () {

					return amount;

				};

				return material;

			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}



			function animate() {

				requestAnimationFrame( animate );
				t_privouseTime = t_currentTime;

				let timeDelta = clock.getDelta();
				sumFrame += timeDelta;
				if(sumFrame > 1.0){
					//console.log(framecnt);
					//console.log(sumFrame);
					framecnt = 0;
					sumFrame = 0;
				}
				framecnt++;
			
				
				if(selectMesh){
					const shader = selectMesh.material.userData.shader;

					if ( shader && sensorXList && sensorYList && sensorZList) {
						let currentTime = startMinDateGlobal + (animCount * 1/hz * 1000);
						t_currentTime = currentTime;
						t_diffTime = currentTime - t_privouseTime;
						if(t_diffTime < 1000){
							//console.log(t_diffTime);
						}


						shader.uniforms.time.value = timeDelta;
						let _animCount = Math.floor(animCount);
						let xT = sensorXList[_animCount];
						let yT = sensorYList[_animCount];
						let zT = sensorZList[_animCount];

						shader.uniforms.sensor_x.value = xT;
						shader.uniforms.sensor_y.value = yT;
						shader.uniforms.sensor_z.value = zT;
						
						//console.log('' + animCount + '/' + sensorXList.length, xT, yT, zT);
						

						if(infoView){
						
							timeStepSlider.slider('value',currentTime);
							infoView.text(''+ new Date(currentTime).toISOString() + ' 진행:'+ (_animCount/sensorXList.length*100).toFixed(2) + '% ' + '    ' + _animCount + '/' + sensorXList.length + '     x:'+xT+'     y:'+yT+'     z:'+zT);

						}

						

						if(!isSliding){
							//animCount++;
							if(t_diffTime <= hz - 0.05 && t_diffTime > hz + 0.05){
								animCount = animCount + timeDelta * speedAnim;
							}else if(t_diffTime < hz - 0.05){
								speedAnim += 0.01;
								animCount = animCount + timeDelta * speedAnim;
							}else if(t_diffTime >= hz + 0.05){
								speedAnim -= 0.01;
								animCount = animCount + timeDelta * speedAnim;
							}
							
						}

						if(animCount > sensorXList.length-1){
							animCount = 0;
							
						}
						
					}
				}
				
				
				renderer.render( scene, camera );
				cameraControls.update();
				stats.update();
	 


				
			}

			function getHeight(mesh){
				var geometry = mesh.geometry;
				geometry.computeBoundingBox();
				return geometry.boundingBox.max.z - geometry.boundingBox.min.z; //건물은 z가 0부터 시작하므로 z의 max값
			}

			function getCenterPoint(mesh) {
				var middle = new THREE.Vector3();
				var geometry = mesh.geometry;
			
				geometry.computeBoundingBox();
			
				middle.x = (geometry.boundingBox.max.x + geometry.boundingBox.min.x) / 2;
				middle.y = (geometry.boundingBox.max.y + geometry.boundingBox.min.y) / 2;
				middle.z = (geometry.boundingBox.max.z + geometry.boundingBox.min.z) / 2;
				
				mesh.localToWorld( middle );
				return middle;
			}

			let interval = null;
			let result = null;

			function initJank() {

				const button = document.getElementById( 'junkButton' );
				button.addEventListener( 'click', function () {

					if ( interval === null ) {

						interval = setInterval( jank, 1000 / 60 );

						button.textContent = 'STOP JANK';

					} else {

						clearInterval( interval );
						interval = null;

						button.textContent = 'START JANK';
						result.textContent = '';

					}

				} );

				result = document.getElementById( 'junkResult' );

			}

			function jank() {

				let number = 0;

				for ( let i = 0; i < 10000000; i ++ ) {

					number += Math.random();

				}

				result.textContent = number;

			}

			function initOutputCsv(){
				$('#outputCsvButton').click(()=>{
					let rows = [
						["StartTime", "Hz", "SampleRate", "x", "y", "z"],
					];
					rows.push([new Date(startMinDateGlobal).toISOString(), String(hz), String(sensorXList.length), '', '', '']);
					for(let i=0; i<sensorXList.length; ++i){
						rows.push(['', '', '', String(sensorXList[i]), String(sensorYList[i]), String(sensorZList[i])]);
					}

					let csvContent = "data:text/csv;charset=utf-8,";

					rows.forEach(function(rowArray) {
						let row = rowArray.join(",");
						csvContent += row + "\r\n";
					});

					var encodedUri = encodeURI(csvContent);
					window.open(encodedUri);
				});
			}
		</script>
	</body>
</html>
